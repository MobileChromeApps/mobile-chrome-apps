{
  "name": "jWorkflow",
  "version": "0.8.0",
  "description": "dude, wheres my workflow?",
  "homepage": "https://github.com/tinyhippos/jWorkflow",
  "author": {
    "name": "gtanner"
  },
  "contributors": [
    {
      "name": "Gord Tanner",
      "email": "gtanner@gmail.com",
      "url": "http://github.com/gtanner"
    }
  ],
  "licenses": [
    {
      "type": "MIT",
      "url": ""
    }
  ],
  "main": "./lib/jWorkflow",
  "readme": "# jWorkflow\nDude, where is my workflow?\n\njWorkflow is a workflow engine for JavaScript that provides the ability to\ncreate workflows to chain methods together in an easy to understand syntax:\n\n    var fooodOrder = jWorkflow.order(garlicChicken)\n                              .andThen(whiteRice)\n                              .andThen(wontonSoup)\n                              .andThen(cookiesFortune)\n                              .andThen(noAndThen)\n                              .andThen(noAndThen)\n                              .andThen(noAndThen)\n                              .andThen(noAndThen);\n\n    fooodOrder.start();\n\n# Install\n\njWorkflow can be used in node or included in the browser.  It can be installed with npm\n\n    npm install jWorkflow\n\nand used\n\n    var jWorkflow = require(\"jWorkflow\");\n\nor just include jWorkflow.js in your webpage and use window.jWorkflow.\n\n# Usage\n\njWorkflow orders are started with a call to jWorkflow.order:\n\n    function dude() {\n        // some of the best code in the world will live here\n    }\n\n    var order = jWorkflow.order(dude);\n\n    // orders can also be started with no initial function\n    var pizzacoli = jWorkflow.order();\n\njWorkflow tasks at the root are just functions that will be invoked in the order they are built.\nAny number of tasks can be then appended to the order:\n\n    order.andThen(sweet).andThen(dude).andThen(sweet);\n\nThe functions passed into the order will not be invoked until you call:\n\n    order.start();\n\nThe context to be used when invoking the functions can be passed in while creating the order:\n\n    order.andThen(transfunctioner.photonAcceleratorAnnihilationBeam, transfunctioner);\n\nAn initial value can be passed into the start method to seed the first function:\n\n    order.start({\n        initialValue: 10\n    });\n\n# Passing Values between tasks\n\njWorkflow tasks can access the return value of the previous task with the previous parameter:\n\n    function meaningOfLife() {\n       //find the meaning of life\n       return 42; \n    }\n    \n    function writeBook(previous) {\n       console.log(\"the meaning of life is \" + previous);\n    }\n\n    var guide = jWorkflow.order(meaningOfLife).andThen(writeBook);\n    guide.start();\n\n# Handling Async calls\n\nSometimes(probably all the time) you will need to do something async when working with\ntasks, jWorkflow provides the ability to control the execution of the workflow via a\nbaton that is passed to the task\n\n    function procrastinate(previous, baton) {\n        //take the baton, this means the next task will not run until you pass the baton\n        baton.take();\n\n        window.setTimeout(function() {\n            //do some stuff\n\n            //please be nice and always remember to pass the baton!\n            baton.pass();\n        }, 1000);\n    }\n\nIf you want to pass a return value to the next task you can pass it along with the\nbaton.\n\nNOTE: if you did take the baton, the return value from your function will NOT be passed to \nthe next task:\n\n    function awesometown(previous, baton) {\n        baton.take();\n\n        window.setTimeout(function() {\n            \n            //do stuff\n            \n            baton.pass(420);    //This value will be passed to the next task\n        }, 100);\n\n        return 50; // this will NOT be passed to the next function since you took the baton.\n    }\n\n\nthe start method provides a callback to execute when the workflow is finished.  The final\nreturn value is also passed to the callback:\n\n   order.start({\n       callback: function(review) {\n               console.log(\"dude!, your car is behind that mail truck!\");\n               expect(review).toBe(\"two thumbs up\");\n       }\n   });\n\nyou can also pass context to use for the callback:\n\n   order.start({\n       callback: function() {\n           //do stuff\n       }, \n       context: transfunctioner\n   });\n    \n# Waiting between tasks\n\nIf you ever need to take a break and reflect on the moment you can add some time(in ms) to chill between tasks:\n\n    jWorkflow.order(seeDoubleRainbow)\n             .chill(1000)\n             .andThen(omg)\n             .andThen(omg)\n             .andThen(omg)\n             .chill(1000)\n             .andThen(freakOut);\n\n# Handling Parallel tasks\n\nIf you need to handle some tasks and don't care about when they are done you can pass in an array of functions and / or other workflows to execute\nat the same time.\n\n    jWorkflow.order([man, man, halfMan])\n             .andThen([jWorkflow.order([guy, guy]).andThen(girl), pizzaPlace]);\n\n# Canceling Workflows\n\nTo cancel the execution of the workflow you can call the drop method on the baton:\n\n    function (previous, baton) {\n        //the value passed to drop will be passed onto the final callback if it exists\n        baton.drop(\"I dropped the soap\");\n        //this value will NOT be passed to the next workflow step\n        return 10;\n    }\n\nNOTE: This will force the workflow into async mode.\n\n# Contributers:\n\n    Gord Tanner <gtanner@gmail.com>\n",
  "readmeFilename": "README.md",
  "_id": "jWorkflow@0.8.0",
  "_from": "jWorkflow@*"
}
